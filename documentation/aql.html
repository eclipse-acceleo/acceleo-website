<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/></head><body><h1 id="AcceleoQueryLanguageAQL">Acceleo Query Language (AQL)</h1><h2 id="Introduction">Introduction</h2><p>The Acceleo Query Language, AQL, is a new query interpreter created to replace the Acceleo MTL engine when used as a simple interpreter. AQL is small, simple, fast, extensible and it brings a richer validation than the MTL interpreter.</p><p>For those looking for a simple and fast interpreters for your EMF models, AQL can provide you with a lot of features, including:</p><ul><li>Support for static and dynamic Ecore models, no compilation phase required.</li><li>The least possible overhead at evaluation time. During this phase, the evaluation goes forward and will not even try to validate or compile your expressions. Errors are tracked and captured along the way.</li><li>Strong validation: types are checked at validation time and the metamodels used are analyzed to do some basic type inference and avoid false positive errors.</li><li>Union types: In some context, a variable in a given query can have N potential types with N being often greater than one. AQL can embrace this fact without having to fall back to EObject as soon as there is more than one type.</li><li>A simple and straightforward implementation easily extensible with Java classes providing extension methods.</li><li>A very narrow dependency surface: AQL uses the very central parts of EMF, Guava and Antlr so that we could easily deploy AQL outside of Eclipse in a server or a standalone scenario.</li></ul><p>The AQL interpreter is used in Sirius with the prefix &#171;aql:&#187; in Sirius.</p><h2 id="LanguageReference">Language Reference</h2><h2 id="MigratingfromMTLqueries">Migrating from MTL queries</h2><p>As languages, AQL and MTL are very close yet there are some notable differences:</p><h3 id="Implicitvariablereferences">Implicit variable references</h3><p>There is no implicit variable reference. With this change, you can easily find out if you are using a feature of an object or a string representation of said object. As a result, instead of using &#171;[something/]&#187;, you must use &#171;aql:self.something&#187; if you want to access the feature named &#171;something&#187; of the current object or &#171;aql:something&#187; if you want to retrieve the object named something.</p><p>In a lambda expression, you must now define the name of the variable used for the iteration in order to easily identify which variable is used by an expression. In Acceleo MTL, you can write &#171;aql:Sequence{self}-&gt;collect(eAllContents(uml::Property))&#187; and Acceleo will use the implicit iterator as a source of the operation eAllContents.</p><p>The problem comes when using a lambda like &#171;aql:Sequence{self}-&gt;collect(something)&#187;, we can&#8217;t know if &#171;something&#187; is a feature of &#171;self&#187; or if it is another variable.</p><p>Using AQL, you will now have to write either &#171;collect(m | m.eAllContents(uml::Property))&#187; or &#171;collect(m: uml::Model | eAllContents(uml::Property))&#187;.</p><h3 id="Collectandflatten">Collect and flatten</h3><p>Auto-collect and auto-flatten, there is no such thing as a Sequence of Sequence in AQL instead everything is flattened by default.</p><h3 id="TypeliteralschildEPackages">Type literals &amp; child EPackages</h3><p>Type literals can&#8217;t be in the form someEPackage::someSubEPackage::SomeEClass but instead someSubEPackage::SomeEClass should be directly used.</p><h3 id="Collections">Collections</h3><p>You can only have Sequences or OrderedSets as collections and as such the order of their elements is always deterministic. In Acceleo MTL, you had access to Sets, which are now OrderedSets and Bags, which are now Sequences. Those four kinds of collections were motivated by the fact that Sequence and OrderedSet were ordered contrary to Sets and Bags. On another side, OrderedSets and Sets did not accept any duplicate contrary to Bags and Sequences.</p><p>By careful reviewing the use of those collections in various Acceleo generators and Sirius Designers we have quickly find out that the lack of determinism in the order of the collections Sets and Bags was a mojor issue for our users. As a result, only two collections remain, the Sequence which can contain any kind of element and the OrderedSet which has a similar behavior except that it does not accept duplicates.</p><p>Previously in Acceleo MTL, you could transform a literal into a collection by using the operator &#171;-&gt;&#187; on the literal directly. Now you will have to declare a collection properly in order to explicitly indicate the type of the collection desired. In Acceleo MTL, the collection created was a Bag which is not available anymore. It is recommended to use a sequence by default. With AQL, you will now write &#171;aql:Sequence{self}&#187; or &#171;aql:OrderedSet{self}&#187;.</p><h3 id="Renamedoperations">Renamed operations</h3><p>Some operations have been renamed. As such &#171;addAll&#187; and &#171;removeAll&#187; have been renamed &#171;add&#187; and &#171;sub&#187; because those two names are used by AQL in order to provide access to the operator &#171;+&#187; and &#171;-&#187;. As a result we can now write in AQL &#171;firstSequence + secondSequence&#187; or &#171;firstSet - secondSet&#187;.</p><h3 id="Typing">Typing</h3><p>AQL is way smarter than MTL regarding to the types of your expressions. As a result, you can combine expressions using multiple types quite easily. For example, this is a valid AQL expression &#171;aql:self.eContents(uml::Class).add(self.eContents(ecore::EClass)).name&#187;. In Acceleo MTL, we could not use this behavior because Acceleo MTL had to fall back to the concept EObject which does not have a feature &#171;name&#187; while AQL knows that the collection contains objects that are either &#171;uml::Class&#187; or &#171;ecore::EClass&#187; and both of those types have a feature named &#171;name&#187;.</p><h2 id="MigratingfromAcceleo2queries">Migrating from Acceleo2 queries</h2><h3 id="EClassifierreferences">EClassifier references</h3><p>All the operation referencing a type are now using a type literal with the name of the EPackage and the name of the type instead of a string with the name of the type. As a result, &#171;eObject.eAllContents('EClass')&#187; would be translated using "eObject.eAllContents(&#8249;ecore::EClass&#8250;). This allow AQL to now in which EPackage to look for the type and as such, it improves the quality of the validation.</p><h3 id="Typesandcast">Types and cast</h3><p>In order to test the type of an EObject, a common pattern in Acceleo 2 was to treat the EObject as a collection and filter said collection on the type desired to see if the size of the collection changed. In AQL, you have access to the operations oclIsTypeOf and oclIsKindOf. You can thus test the type of an EObject with the expression &#171;eObject.oclIsKindOf(ecore::EStructuralFeature)&#187; or &#171;eObject.oclIsTypeOf(ecore::EAttribute)&#187;. You can use the operation oclIsKindOf to test if an object has the type of the given parameter or one of its subtype. On the other hand, you can use the operation oclIsTypeOf to test if an object has exactly the type of the given parameter.</p><p>Casting in AQL is useless, since AQL is very understandable whtn it comes to types, it will always tries its best to evaluate your expression.</p><p>Since AQL is very close to Acceleo MTL, you can find some additional documentation using the Acceleo equivalence documentation in the <a href="http://help.eclipse.org/mars/index.jsp?topic=%2Forg.eclipse.acceleo.doc%2Fdoc%2Fhtml%2Facceleo_equivalence.html">Acceleo documentation</a>.</p></body></html>